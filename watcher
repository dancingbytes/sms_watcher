#!/usr/bin/env ruby
# encoding: utf-8
require "rubygems"
require "bundler/setup"

require "net/http"
require "json"
require "cgi"
require "uri"
require "timeout"
require ::File.expand_path('../sms', __FILE__)

module Watcher

  extend self

  SITES_DIR = ::File.expand_path('../sites', __FILE__)
  TMP_DIR   = ::File.expand_path('../tmp',   __FILE__)
  LOCKLIFE  = 30*60 # 30 минут
  TIMEOUT   = 30    # 30 секунд

  def run

    begin

      # Файл блокировки
      flock = ::File.join(::Watcher::TMP_DIR, ".watcher.lock")

      # Если файл блокировки уже есть - завершаем работу.
      return if ::File.exist?(flock)

      # Иначе, создаем файл
      f = ::File.new(flock, ::File::RDWR|::File::CREAT, 0400)

      # Выполняем блок
      begin
        check_all
      ensure
        # Все зависмости от того, как выполнился блок, удаляем файл блокировки,
        # если он еще существует
        ::File.unlink(flock) if ::File.exist?(flock)
      end

    # Если поймана ошибка доступа -- игнорируем её.
    rescue ::Errno::EACCES
    end

  end # run

  private

  def check_all

    # Проверяем сайты по списку
    get_sites do |site, phones|

      # Если сайт не отвечает -- метод ::Net::HTTP.get_response возвращает
      # экземпляр класса отличный от ::Net::HTTPSuccess -- рассылаем смс.
      check(site) do |success|

        # Что бы не слать каждые 10 минут смс, создаем файл блокировки
        lock = generate_lock(site)

        # Если результат проверки отрицательный (сайт не доступен)
        unless success

          # Если файл блокировки задан и дата создания валидна (файл не старее указанного периода)
          # то, переходим на следующую итерацию цикла
          next if locked?(lock)

          # Иначе, создаем файл блокировку
          create_lock(lock, site)

          # Шлем сообщения
          send_message(phones, "Сайт #{site} не доступен. #{::Time.now}")

        else

          # Сайт доступен. Если была блокировка, удаляем её и шлем сообщение о доступности сайта.
          send_message(phones, "Сайт #{site} доступен. #{::Time.now}") if remove_lock(lock)

        end # if

      end # check

    end # get_sites

  end # check_all

  def get_sites

    ::Dir.foreach(::Watcher::SITES_DIR) { |el|

      file = ::File.join(::Watcher::SITES_DIR, el)

      # Если el не является файлом -- следующий!
      next unless ::File.file?(file)

      # Выбирааем из файла название (названием сайта, которое мы потом проверим :) )
      site    = el
      phones  = []

      # Читаем файл и построчно выбираем телефоны (ну илми чтотам есть)
      ::File.open(file, "r") { |fl|

        ::IO.readlines(fl).each { |line|
          phones << (line || [])
        }

      }

      # Выполняем блок с полученными данными
      yield(site, phones.compact)

    } # foreach

  end # get_sites

  # Хитро генерим из адреса сайта название файла
  def generate_lock(site_name)
    ::File.join(::Watcher::TMP_DIR, "#{site_name}.lock")
  end # generate_lock

  # Создаем файл блокировки, записываем в него название сайта и время записи.
  def create_lock(file, site)

    ::File.open(file, "w") { |f|
      f.write("#{site} - #{::Time.now}")
    }

  end # create_lock

  # Рассылаем сообщения str на телефоны phones
  def send_message(phones, str)

    phones.each do |phone|
      ::SMS.message(phone, str)
    end # each

  end # send_message

  def locked?(lock)

    # Если файла блокировки не существут -- false
    return false unless ::File.exists?(lock)
    # Если файла блокировки имеется и не устарел -- успех
    return true  if (::Time.now - ::File.atime(lock)) < ::Watcher::LOCKLIFE

    # Иначе удаляекм файл блокировки -- false
    ::File.unlink(lock)
    false

  end # locked?

  # Если файл блокировки существует -- удаляем и сообщаем об успехе, иначе false
  def remove_lock(lock)

    if ::File.exists?(lock)
      ::File.unlink(lock)
      true
    else
      false
    end

  end # remove_lock

  def check(site)

    # Строим url
    url = ::URI.extract("http://#{site}").first

    # Если ничего не получилось -- завершаем работу
    return unless url

    # Проверям доступность сайта
    begin

      ::Timeout::timeout(::Watcher::TIMEOUT) {

        req = ::Net::HTTP.get_response(URI(url))
        yield(req.is_a?(::Net::HTTPSuccess))

      }

    rescue
      # Возникла какая-то ошибка
      yield(false)
    end

  end # check

end # Watcher


::SMS.login('login', 'passwrd')

at_exit {
  ::SMS::logout
}

::Watcher.run
